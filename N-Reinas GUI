import tkinter as tk
from tkinter import ttk
from tkinter import messagebox

import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np

# ======================================================
#  ALGORITMO N-REINAS (TU LÓGICA)
# ======================================================

def es_seguro(tablero, fila, col):
    for i in range(fila):
        if tablero[i] == col or abs(tablero[i] - col) == abs(i - fila):
            return False
    return True

def resolver_rec(n, fila, tablero, soluciones):
    if fila == n:
        soluciones.append(tablero.copy())
        return
    for col in range(n):
        if es_seguro(tablero, fila, col):
            tablero[fila] = col
            resolver_rec(n, fila + 1, tablero, soluciones)

def n_reinas(n):
    tablero = [-1] * n
    soluciones = []
    resolver_rec(n, 0, tablero, soluciones)
    return soluciones

# -------------------- Simetrías --------------------

def rotar90(sol):
    n = len(sol)
    r = [0] * n
    for fila, col in enumerate(sol):
        r[col] = n - 1 - fila
    return r

def reflejar(sol):
    n = len(sol)
    return [n - 1 - c for c in sol]

def generar_simetrias(sol):
    r90 = rotar90(sol)
    r180 = rotar90(r90)
    r270 = rotar90(r180)
    refl = reflejar(sol)
    refl90 = rotar90(refl)
    refl180 = rotar90(refl90)
    refl270 = rotar90(refl180)
    return [sol, r90, r180, r270,
            refl, refl90, refl180, refl270]

def es_nueva(sol, unicas):
    for u in unicas:
        if any(s == u for s in generar_simetrias(sol)):
            return False
    return True

def filtrar_unicas(soluciones):
    unicas = []
    for sol in soluciones:
        if es_nueva(sol, unicas):
            unicas.append(sol)
    return unicas

# -------------------- DIBUJO DE LA REINA --------------------

def dibujar_reina(ax, x, y, tamaño):
    ax.plot([x+0.25*tamaño, x+0.15*tamaño, x+0.40*tamaño,
             x+0.50*tamaño, x+0.60*tamaño,
             x+0.85*tamaño, x+0.75*tamaño],
            [y+0.65*tamaño, y+0.90*tamaño, y+0.80*tamaño,
             y+0.95*tamaño, y+0.80*tamaño,
             y+0.90*tamaño, y+0.65*tamaño],
            color="black", linewidth=2)

    circ = plt.Circle((x + 0.50*tamaño, y + 0.55*tamaño), tamaño*0.18, color='black')
    ax.add_patch(circ)

    ax.add_patch(plt.Rectangle((x + 0.20*tamaño, y + 0.20*tamaño),
                               tamaño*0.60, tamaño*0.15, color="black"))

# -------------------- DIBUJADO DE TABLEROS --------------------

def dibujar_tablero(ax, sol, n):
    for i in range(n):
        for j in range(n):
            color = "#f0d9b5" if (i + j) % 2 == 0 else "#b58863"
            ax.add_patch(plt.Rectangle((j, n-1-i), 1, 1, color=color))

    for i in range(n):
        dibujar_reina(ax, sol[i], n-1-i, 1)

    ax.add_patch(plt.Rectangle((0, 0), n, n,
                               fill=False, linewidth=3, edgecolor="black"))

    # Para que no se vean ejes
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_xlim(0, n)
    ax.set_ylim(0, n)
    ax.set_aspect("equal")
    ax.grid(False)

# ======================================================
#  GUI CON SCROLL
# ======================================================

class NReinasGUI:

    def __init__(self, root):
        self.root = root
        self.root.title("N-Reinas – Soluciones sin simetrías (scroll)")

        # ------------ Parte superior: entrada y botón ------------
        frame_top = ttk.Frame(root)
        frame_top.pack(pady=10)

        ttk.Label(frame_top, text="Introduce N: ").grid(row=0, column=0)
        self.entry_n = ttk.Entry(frame_top, width=10)
        self.entry_n.grid(row=0, column=1, padx=5)

        ttk.Button(frame_top, text="Resolver", command=self.resolver).grid(row=0, column=2, padx=10)

        # Info de soluciones
        self.lbl_info = ttk.Label(root, text="")
        self.lbl_info.pack(pady=5)

        # ------------ Área scrollable para las soluciones ------------
        self.frame_scroll = ttk.Frame(root)
        self.frame_scroll.pack(fill="both", expand=True)

        # Canvas + Scrollbar
        self.canvas = tk.Canvas(self.frame_scroll)
        self.scrollbar = ttk.Scrollbar(self.frame_scroll, orient="vertical", command=self.canvas.yview)
        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        self.canvas.pack(side="left", fill="both", expand=True)
        self.scrollbar.pack(side="right", fill="y")

        # Frame interior que se moverá con el scroll
        self.inner_frame = ttk.Frame(self.canvas)
        self.canvas.create_window((0, 0), window=self.inner_frame, anchor="nw")

        # Cuando cambie el tamaño del inner_frame, actualizar scrollregion
        self.inner_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )

        # Estado
        self.soluciones = []
        self.n = 0

        # Permitir scroll con rueda del ratón (opcional)
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)

    def _on_mousewheel(self, event):
        # En Windows suele ser event.delta con múltiplos de 120
        self.canvas.yview_scroll(int(-event.delta / 120), "units")

    # -------------------- LÓGICA PRINCIPAL --------------------

    def resolver(self):
        try:
            n = int(self.entry_n.get())
            if n <= 0:
                raise ValueError
        except:
            messagebox.showerror("Error", "Introduce un número entero positivo.")
            return

        self.n = n
        todas = n_reinas(n)
        unicas = filtrar_unicas(todas)
        self.soluciones = unicas

        self.lbl_info.config(
            text=f"Soluciones totales: {len(todas)} | Sin simetrías: {len(unicas)}"
        )

        self.mostrar_todas_en_scroll()

    def mostrar_todas_en_scroll(self):
        # Borrar todo lo que hubiera antes en el frame scrollable
        for widget in self.inner_frame.winfo_children():
            widget.destroy()

        columnas = 4
        fig_size = 2.8  # tamaño de cada tablero

        for idx, sol in enumerate(self.soluciones):
            fila = idx // columnas
            col = idx % columnas

            frame = ttk.Frame(self.inner_frame)
            frame.grid(row=fila, column=col, padx=10, pady=10)

            fig = plt.Figure(figsize=(fig_size, fig_size))
            ax = fig.add_subplot(111)
            dibujar_tablero(ax, sol, self.n)

            canvas = FigureCanvasTkAgg(fig, master=frame)
            canvas_widget = canvas.get_tk_widget()
            canvas_widget.pack()

            ttk.Label(frame, text=f"Solución {idx + 1}").pack(pady=2)

# ======================================================
# MAIN
# ======================================================

if __name__ == "__main__":
    root = tk.Tk()
    root.geometry("1000x700")  # opcional: tamaño inicial de la ventana
    app = NReinasGUI(root)
    root.mainloop()
